package jsonschemagen

import (
	"go/ast"
	"slices"

	"github.com/google/jsonschema-go/jsonschema"
	"ocm.software/open-component-model/bindings/go/generator/universe"
)

const (
	JSONSchemaDraft202012URL = "https://json-schema.org/draft/2020-12/schema"
	GeneratedComment         = "generated by the ocm schema generation tool"
)

func (g *Generator) buildRootSchema(ti *universe.TypeInfo) *jsonschema.Schema {
	switch {
	case universe.IsRuntimeRaw(ti):
		return g.builtinRuntimeRaw()
	case universe.IsRuntimeTyped(ti):
		return g.builtinRuntimeTyped()
	case universe.IsRuntimeType(ti):
		return g.builtinRuntimeType()
	}

	if ti.Struct != nil {
		desc, deprecated := extractStructDoc(ti.TypeSpec, ti.GenDecl)
		out := &jsonschema.Schema{
			Schema:               JSONSchemaDraft202012URL,
			Comment:              GeneratedComment,
			ID:                   g.schemaID(ti),
			Title:                ti.Key.TypeName,
			Description:          desc,
			Type:                 "object",
			Properties:           g.buildStructProperties(ti.Struct, ti),
			Required:             g.buildStructRequired(ti.Struct),
			AdditionalProperties: &jsonschema.Schema{Not: &jsonschema.Schema{}},
		}
		if deprecated {
			out.Deprecated = true
		}
		return out
	}

	return g.buildAliasSchema(ti)
}

func (g *Generator) buildAliasSchema(ti *universe.TypeInfo) *jsonschema.Schema {
	desc, deprecated := extractStructDoc(ti.TypeSpec, ti.GenDecl)

	var sch *jsonschema.Schema

	switch t := ti.Expr.(type) {
	case *ast.Ident:
		if prim := newPrimitiveSchema(t, ti.TypeSpec, ti.GenDecl, nil); prim != nil {
			sch = prim
		}
	case *ast.ArrayType:
		sch = &jsonschema.Schema{
			Type:  "array",
			Items: g.schemaForExpr(t.Elt, ti, nil),
		}
	case *ast.MapType:
		sch = &jsonschema.Schema{
			Type:                 "object",
			AdditionalProperties: g.schemaForExpr(t.Value, ti, nil),
		}
	}

	if sch == nil {
		sch = anyObjectSchema()
	}

	sch.Schema = JSONSchemaDraft202012URL
	sch.Comment = GeneratedComment
	sch.ID = g.schemaID(ti)
	sch.Title = ti.Key.TypeName
	sch.Description = desc
	if deprecated {
		sch.Deprecated = true
	}

	ApplyConstEnum(sch, ti.Consts)
	return sch
}

func (g *Generator) schemaForExpr(
	expr ast.Expr,
	ctx *universe.TypeInfo,
	field *ast.Field,
) *jsonschema.Schema {
	if sch, ok := g.schemaRefForExpr(expr, ctx); ok {
		applyMarkers(sch, ctx.TypeSpec, ctx.GenDecl, field)
		return sch
	}

	switch t := expr.(type) {
	case *ast.StarExpr:
		return g.schemaForExpr(t.X, ctx, field)
	case *ast.ArrayType:
		return &jsonschema.Schema{
			Type:  "array",
			Items: g.schemaForExpr(t.Elt, ctx, field),
		}
	case *ast.MapType:
		return &jsonschema.Schema{
			Type:                 "object",
			AdditionalProperties: g.schemaForExpr(t.Value, ctx, field),
		}
	case *ast.StructType:
		return g.inlineAnonymousStruct(t, ctx)
	case *ast.Ident:
		if prim := newPrimitiveSchema(t, ctx.TypeSpec, ctx.GenDecl, field); prim != nil {
			return prim
		}
	}
	return anyObjectSchema()
}

func (g *Generator) schemaRefForExpr(
	expr ast.Expr,
	ctx *universe.TypeInfo,
) (*jsonschema.Schema, bool) {

	ti, ok := g.U.ResolveExpr(
		ctx.Pkg.TypesInfo,
		ctx.Key.PkgPath,
		expr,
	)
	if !ok {
		return nil, false
	}

	if schema, ok := SchemaFromUniverseType(ti); ok {
		out := &jsonschema.Schema{}
		ApplyFileMarkers(out, schema, ti.FilePath)
		return out, true
	}

	out := &jsonschema.Schema{
		Ref: "#/$defs/" + universe.Definition(ti.Key),
	}
	return out, true
}

func applyMarkers(
	sch *jsonschema.Schema,
	typeSpec *ast.TypeSpec,
	genDecl *ast.GenDecl,
	field *ast.Field,
) {
	typeMarkers := ExtractMarkerMap(typeSpec, genDecl, BaseMarker)
	ApplyEnumMarkers(sch, typeMarkers)
	ApplyNumericMarkers(sch, typeMarkers)

	if field != nil {
		fieldMarkers := ExtractMarkerMapFromField(field, BaseMarker)
		ApplyEnumMarkers(sch, fieldMarkers)
		ApplyNumericMarkers(sch, fieldMarkers)
	}
}

func (g *Generator) buildStructProperties(
	st *ast.StructType,
	ti *universe.TypeInfo,
) map[string]*jsonschema.Schema {

	props := make(map[string]*jsonschema.Schema)

	for _, field := range st.Fields.List {
		if len(field.Names) == 0 {
			continue
		}

		name, _ := parseJSONTagWithFieldNameFallback(field)
		if name == "-" {
			continue
		}

		sch := g.schemaForExpr(field.Type, ti, field)

		desc, deprecated := extractFieldDoc(field)
		if desc != "" {
			sch.Description = desc
		}
		if deprecated {
			sch.Deprecated = true
		}

		props[name] = sch
	}
	return props
}

func (g *Generator) buildStructRequired(st *ast.StructType) []string {
	var req []string
	for _, f := range st.Fields.List {
		if len(f.Names) == 0 {
			continue
		}
		name, opts := parseJSONTagWithFieldNameFallback(f)
		if name == "-" || slices.Contains(opts, "omitempty") {
			continue
		}
		req = append(req, name)
	}
	return req
}

func (g *Generator) inlineAnonymousStruct(
	st *ast.StructType,
	ctx *universe.TypeInfo,
) *jsonschema.Schema {

	props := map[string]*jsonschema.Schema{}
	var req []string

	for _, field := range st.Fields.List {
		if len(field.Names) == 0 {
			continue
		}

		name, opts := parseJSONTagWithFieldNameFallback(field)
		if name == "-" {
			continue
		}

		sch := g.schemaForExpr(field.Type, ctx, field)

		desc, deprecated := extractFieldDoc(field)
		if desc != "" {
			sch.Description = desc
		}
		if deprecated {
			sch.Deprecated = true
		}

		props[name] = sch
		if !slices.Contains(opts, "omitempty") {
			req = append(req, name)
		}
	}

	return &jsonschema.Schema{
		Type:                 "object",
		Properties:           props,
		Required:             req,
		AdditionalProperties: &jsonschema.Schema{Not: &jsonschema.Schema{}},
	}
}

func (g *Generator) collectReachableQueue(
	root *universe.TypeInfo,
) []*universe.TypeInfo {

	seen := map[universe.TypeKey]bool{}
	var out []*universe.TypeInfo

	var walk func(*universe.TypeInfo)
	walk = func(ti *universe.TypeInfo) {
		if seen[ti.Key] {
			return
		}
		seen[ti.Key] = true

		if ti != root {
			out = append(out, ti)
		}

		if universe.IsRuntimeTyped(ti) {
			if rt := g.U.LookupType(universe.RuntimePackage, "Raw"); rt != nil {
				walk(rt)
			}
		}

		if ti.Struct != nil {
			for _, f := range ti.Struct.Fields.List {
				if ref, ok := g.U.ResolveExpr(
					ti.Pkg.TypesInfo,
					ti.Key.PkgPath,
					f.Type,
				); ok {
					walk(ref)
				}
				g.collectFromExpr(f.Type, ti, walk)
			}
			return
		}

		g.collectFromExpr(ti.Expr, ti, walk)
	}

	walk(root)
	return out
}

func (g *Generator) collectFromExpr(
	expr ast.Expr,
	ctx *universe.TypeInfo,
	walk func(*universe.TypeInfo),
) {
	if ti, ok := g.U.ResolveExpr(
		ctx.Pkg.TypesInfo,
		ctx.Key.PkgPath,
		expr,
	); ok {
		if _, skip := SchemaFromUniverseType(ti); !skip {
			walk(ti)
		}
		return
	}

	switch t := expr.(type) {
	case *ast.StarExpr:
		g.collectFromExpr(t.X, ctx, walk)
	case *ast.ArrayType:
		g.collectFromExpr(t.Elt, ctx, walk)
	case *ast.MapType:
		g.collectFromExpr(t.Value, ctx, walk)
	case *ast.StructType:
		for _, f := range t.Fields.List {
			g.collectFromExpr(f.Type, ctx, walk)
		}
	}
}

func (g *Generator) schemaID(ti *universe.TypeInfo) string {
	return ti.Key.PkgPath + "/schemas/" + ti.Key.TypeName + ".schema.json"
}

func anyObjectSchema() *jsonschema.Schema {
	return &jsonschema.Schema{
		Type:                 "object",
		AdditionalProperties: &jsonschema.Schema{},
	}
}

func Ptr[T any](v T) *T { return &v }
